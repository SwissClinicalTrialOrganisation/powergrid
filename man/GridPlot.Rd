% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gridplot.R
\name{GridPlot}
\alias{GridPlot}
\title{Plot Combinations of Parameters for Achieving Target}
\usage{
GridPlot(
  x,
  slicer = NULL,
  y_par = NULL,
  x_par = NULL,
  l_par = NULL,
  par_labels = NULL,
  example = NULL,
  target = 0.8,
  method = "step",
  minimal_target = TRUE,
  find_min = TRUE,
  col = grDevices::grey.colors(length(dimnames(x)[[l_par]])),
  title = NULL,
  xlim = NULL,
  ylim = NULL,
  smooth = FALSE
)
}
\arguments{
\item{x}{An object of class "power_array" (from \code{powergrid}), "power" (from
sse::powEx) or "powCalc" (from sse::powCalc).}

\item{slicer}{If the parameter grid of \code{x} has more than 3 dimensions, a
3-dimensional slice must be cut out using \code{slicer}, a list whose
elements define at which values (the list element value) of which
parameter (the list element name) the slice should be cut.}

\item{y_par, x_par, l_par}{Which parameter is varied on the x- and y-axis, and
between lines, respectively. If NULL, \code{y_par} is set to the first,
\code{x_par} to the second, and \code{l_par} to the third dimension name
of \code{x}.}

\item{par_labels}{Named vector where elements names represent the parameters
that are plotted, and the values set the desired labels.}

\item{example}{A list defining for which combination of levels of
\code{l_par} and \code{x_par} an example arrow should be drawn. List
element names indicate the parameter, element value indicate the values at
which the example is drawn.}

\item{target}{The target power (or any other value stored in x) that should
be matched.}

\item{method}{The method to find the required parameter values, see
\code{Example} and \code{FindTarget}.}

\item{minimal_target}{Logical. Should target be minimally achieved (e.g.,
power), or maximially allowed (e.g., estimation uncertainty).}

\item{find_min}{Logical, indicating whether the example should be found that
minimizes an assumption (e.g., minimal required n) to achieve the
\code{target} or an example that maximizes this assumption (e.g.,
maximally allowed SD).}

\item{col}{A vector with the length of \code{l_par} defining the color(s) of
the lines.}

\item{title}{Character string, if not \code{NULL}, replaces default figure
title.}

\item{xlim, ylim}{See \code{?graphics::plot}.}

\item{smooth}{Logical. If TRUE, a 5th order polynomial is fitted though the
points constituting each line for smoothing.}
}
\value{
A list with graphical information to use in further plotting.
}
\description{
Plots the relation between up to three parameters and,
typically, power. Two parameters are represented by x- and y-axes, one by
separate lines.
}
\details{
In the most typical use case, the y-axis shows the \emph{minimal} sample
size required to achieve a power of \emph{at least} \code{target}, assuming the
value of the parameter on the x-axis, and the value of the parameter
represented by each line.

The use of this function is, however, not limited to finding a minimum n to
achieve at least a certain power. See help of \code{Example} to understand the
use of \code{minimal_target} and \code{fin_min}.

Note that a line may stop in a corner of the plotting region, not reaching
the margin. This is often natural behavior, when the \code{target} level is
not reached anywhere in that corner of the parameter range. In case n is on
the y-axis, this may easily be solved by adding larger sample sizes to the
grid (consider \code{Update}), and then adjusting the y-limit to only
include the values of interest.
}
\examples{
sse_pars = list(
  n = seq(from = 2, to = 100, by = 2),
  delta = seq(from = 0.1, to = 1.5, by = 0.05), ## effect size
  sd = seq(.1, .9, .1)) ## Standard deviation
PowFun <- function(n, delta, sd){
  ptt = power.t.test(n = n/2, delta = delta, sd = sd,
                     sig.level = 0.05)
  return(ptt$power)
}
power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA)
GridPlot(power_array, target = .8)
## If that's too many lines, cut out a desired number of slices
GridPlot(power_array,
         slicer = list(sd = seq(.1, .9, .2)),
         target = .8)

## adjust labels, add example
GridPlot(power_array, target = .8,
         slicer = list(sd = seq(.1, .9, .2)),
         y_par = 'n',
         x_par = 'delta',
         l_par = 'sd',
         par_labels = c('n' = 'Sample Size',
                        'delta' = 'Arm Difference',
                        'sd' = 'Standard Deviation'),
         example = list(sd = .7, delta = .6))
## Above, GridPlot used the default: The first dimension is what you search
## (often n), the 2nd and 3rd define the grid of parameters at which the search
## is done. Setting this explicitly, with x, y, and l-par, it looks like:
GridPlot(power_array, target = .8,
         slicer = list(sd = seq(.1, .9, .2)),
         y_par = 'n', # search the smallest n where target is achieved
         x_par = 'delta',
         l_par = 'sd')

## You may also want to have different parameters on lines and axes:
GridPlot(power_array, target = .8,
         y_par = 'delta', # search the smallest delta where target is achieved
         x_par = 'sd',
         l_par = 'n')
## Too many lines! Take some slices again:
GridPlot(power_array, target = .8,
         slicer = list(n = c(seq(10, 70, 16))),
         y_par = 'delta',
         x_par = 'sd',
         l_par = 'n', method = 'step')
}
\seealso{
\code{\link{PowerGrid}}, \code{\link{AddExample}},
\code{\link{Example}}, \code{\link{PowerPlot}} for more basic plotting
of 2 parameters.
}
\author{
Gilles Dutilh
}

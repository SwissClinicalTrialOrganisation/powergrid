% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powergrid.R
\name{PowerGrid}
\alias{PowerGrid}
\title{Evaluate Function (iteratively) at Grid of Input Arguments}
\usage{
PowerGrid(
  pars,
  fun,
  more_args = NULL,
  n_iter = NA,
  summarize = TRUE,
  summary_function = mean,
  parallel = FALSE,
  n_cores = future::availableCores() - 1
)
}
\arguments{
\item{pars}{A list where each element is a vector of values named as one of
the arguments of \code{fun}. \code{fun} is applied to the full grid crossing
the values of each of these parameters.}

\item{fun}{Function applied at each combination of \code{pars}. Arguments
may contain all element names of \code{pars} and \code{more_args}. Output
should be a vector, typically of length one, but more outputs are
generally handled properly in further functions of powergrid.}

\item{more_args}{Fixed arguments to \code{fun} that are not in
\code{pars}. (internally used in \code{.mapply} for supplying argument
\code{MoreArgs})}

\item{n_iter}{If not NA, function \code{fun} is applied \code{n_iter} times
at each point in the grid defined by \code{pars}.}

\item{summarize}{Logical indicating whether iterations (if \code{n_iter} is
given) are to be summarized by \code{summary_function}.}

\item{summary_function}{A function to be applied to aggregate across
simulations. Defaults to \code{mean}, ignored when \code{keep_sims} ==
TRUE or when \code{is.na(n_iter)}.}

\item{parallel}{Logical indicating whether parallel computing should be
applied. If TRUE, future::future_replicate is used internally.}

\item{n_cores}{Passed on to future_replicate}
}
\value{
An array of class "power_array"
}
\description{
PowerGrid is an apply-like function, allowing to evaluate a function at the
crossings of a set of parameters. The result is saved in an array with
attributes that optimize further usage by functions in package
\code{powergrid}. In particular, performing a function iteratively (using
parallel computing if required) is implemented conveniently. The typical use
is for evaluating statistical power at a grid of assumed parameters.
}
\details{
Function \code{fun} is evaluated at each combination of the argument values
listed in \code{pars} and its results are stored in an array whose
dimensions (and \code{dimnames()}) are defined by \code{pars}. If function
\code{fun} returns more than one value (always as a single vector), the
array will have an additional dimension, with levels named after the names
of the returned vector (if given). If n_iter is not NA, function \code{fun}
is evaluated n_iter times. This will add to the resulting array an
additional dimension 'sim'.

The elements of \code{pars} must match the argument names of fun. If input
parameters are not to be part of the grid, but rather further settings,
these can be passed on to \code{fun} through the argument \code{more_args}
as a list with names reflecting the arguments of \code{fun} to be set.
}
\examples{
## ============================================
## most basic case, power function available:
## ============================================
sse_pars = list(
  n = seq(from = 10, to = 60, by = 2),
  delta = seq(from = 0.5, to = 1.5, by = 0.2), ## effect size
  sd = seq(.1, .9, .2)) ## Standard deviation
PowFun <- function(n, delta, sd){
  ptt = power.t.test(n = n/2, delta = delta, sd = sd,
                     sig.level = 0.05)
  return(ptt$power)
}
power_array = PowerGrid(pars = sse_pars, fun = PowFun, n_iter = NA)
##'
summary(power_array)

## ============================================
## Multiple outputs are automatically handled
## ============================================
TwoValuesFun <- function(n, delta, sd){
  p5 = power.t.test(n = n, delta = delta, sd = sd, sig.level = .05)$power
  p1 = power.t.test(n = n, delta = delta, sd = sd, sig.level = .01)$power
  return(c('p5' = p5, 'p1' = p1))
}
##
sse_pars = list(
  n = seq(from = 10, to = 60, by = 2),
  delta = seq(from = 0.5, to = 1.5, by = 0.2),
  sd = seq(.5, 1.5, .2))
array_two_returns = PowerGrid(sse_pars, TwoValuesFun)
## multiple outputs result in an additional dimension:
dimnames(array_two_returns)
summary(array_two_returns)

## ============================================
## Simulations over iterations
## ============================================
PowFun <- function(n, delta, sd){
  x1 = rnorm(n = n/2, sd = sd)
  x2 = rnorm(n = n/2, mean = delta, sd = sd)
  t.test(x1, x2)$p.value < .05
}
sse_pars = list(
  n = seq(from = 10, to = 60, by = 5),
  delta = seq(from = 0.5, to = 1.5, by = 0.2),
  sd = seq(.5, 1.5, .2))
##
n_iter = 20
power_array = PowerGrid(pars = sse_pars, fun = PowFun,
                       n_iter = n_iter)
dimnames(power_array)
summary(power_array)
}
\author{
Gilles Dutilh
}
